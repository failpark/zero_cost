\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{float}
\usepackage[newfloat]{minted}
\usepackage{svg}
\usepackage[style=ieee]{biblatex}
\usepackage{hyperref}
\addbibresource{literature.bib}
\usepackage{etoolbox}
\BeforeBeginEnvironment{minted}{\vspace{-0.2\baselineskip}}
\AfterEndEnvironment{minted}{\vspace{-0.2\baselineskip}}

% Minted style configuration
\setminted{
	fontsize=\footnotesize,
	breaklines=true,
	frame=single,
	numbers=left,
	numbersep=5pt,
	tabsize=2
}

\begin{document}

\title{
	Zero-Cost State Management: Comparing Rust Typestate and C Runtime Checks at the Assembly Level
}

\author{
	\IEEEauthorblockN{Daniel Borgs}
	\IEEEauthorblockA{
		\textit{Faculty of Computer Science and Business Information Systems} \\
		\textit{Technical University of Applied Sciences Würzburg-Schweinfurt}\\
		Würzburg, Germany \\
		daniel.borgs@study.thws.de
	}
}

\maketitle

\begin{abstract}
Memory safety vulnerabilities constitute the majority of security flaws in systems software, with Microsoft reporting rates of approximately 70\%.
C requires explicit runtime checks for state validation, introducing conditional branches and overhead.
Rust claims zero-cost abstractions: compile-time verification without runtime penalty.
This paper investigates whether Rust's typestate pattern produces assembly identical to unsafe C code.

Three file handle state machine implementations were compared:

\begin{enumerate}
	\item defensive C with runtime validation,
	\item minimal C without checks,
	\item and Rust with compile-time typestate enforcement.
\end{enumerate}

Assembly analysis at -O2 optimization on ARM64 measured instruction counts and conditional branches.

Results demonstrate that Rust produces assembly identical
to minimal C (2 instructions, 0 branches) while defensive C requires 7 instructions with 2 branches.
These findings validate that compile-time type checking eliminates runtime overhead while preventing invalid state transitions.
\end{abstract}

\begin{IEEEkeywords}
memory safety, typestate, Rust, C, zero-cost abstractions, compile-time verification, ARM64
\end{IEEEkeywords}

\section{Introduction}

Memory safety vulnerabilities remain the dominant class of security flaws in systems software.
According to the 2025 CWE Top 25 Most Dangerous Software Weaknesses, memory corruption vulnerabilities rank highly:
Out-of-bounds Write (CWE-787, \#5), Use After Free (CWE-416, \#7), and Out-of-bounds Read (CWE-125, \#8)\ \cite{cwe_2025}.
Microsoft reports that approximately 70\% of their security vulnerabilities are memory safety issues\ \cite{microsoft_safety}.
The U.S. Cybersecurity and Infrastructure Security Agency (CISA)
has issued guidance urging software manufacturers to adopt memory-safe languages\ \cite{cisa_memory}.

Systems programming languages such as C provide the low-level control necessary for performance-critical code.
However, C places the entire burden of correctness on the programmer.
State management is ensuring operations occur only when preconditions are met\ \cite{google_paper}.
These must be enforced through explicit runtime checks.
In C, state is typically tracked with an enum field, and each operation checks this field before proceeding, introducing conditional branches with associated overhead.

This creates a fundamental tension: defensive programming incurs runtime overhead, while omitting checks permits undefined behavior.
Higher-level languages enforce safety through garbage collection and runtime checks,
but these mechanisms limit their applicability to resource-constrained systems\ \cite{oncd_report}.

Rust takes a different approach: encoding invariants in the type system so that invalid programs fail to compile.
Rust's design philosophy emphasizes \emph{zero-cost abstractions}---high-level constructs that compile to code as efficient as hand-written low-level equivalents\ \cite{rust_embedded}.
Generic type parameters are instantiated through monomorphization, generating specialized machine code for each concrete type at compile time rather than using runtime dispatch.
This paper hypothesizes that Rust's typestate pattern produces assembly identical to unchecked C while providing compile-time safety guarantees.
The central aim of this study is: Can compile-time state verification eliminate runtime overhead while preventing invalid state transitions?

\section{Background}

Strom and Yemini introduced typestate in 1986 as a compile-time technique to detect invalid execution sequences\ \cite{strom_typestate_1986}.
Their formulation tracked variables through states like ``uninitialized'' or ``deallocated,'' with the compiler verifying state flow through program paths.
The typestate pattern encodes an object's state in its type: rather than a single \texttt{FileHandle} type with a state field,
each state becomes a distinct type (\texttt{FileHandle<Closed>}, \texttt{FileHandle<Open>}, etc.).
Operations consume the input type and produce the output type---the \texttt{open} method takes \texttt{FileHandle<Closed>} by value and returns \texttt{FileHandle<Open>}, invalidating the original handle.
Attempting to call \texttt{read} on a \texttt{FileHandle<Closed>} produces a compile-time error; the method does not exist for that type.

Rust applies affine types, meaning values can be used at most once, enabling memory safety without garbage collection.
The borrow checker prevents use-after-free by tracking ownership at compile time\ \cite{astrauskas_leveraging_2019}.
While Rust lacks explicit typestate abstractions, its type system supports implementing them through generic parameters
and zero-sized \texttt{PhantomData} markers that occupy no memory\ \cite{rust_reference_phantomdata}.

Typestate analysis, sometimes called \emph{protocol analysis},
defines valid sequences of operations that can be performed upon an instance of a given type\ \cite{deline_typestates_2004}. 
DeLine and Fähndrich demonstrated how typestate can enforce high-level protocols in low-level software,
describing resource management protocols that specify operations must be performed in a certain order\ \cite{deline_enforcing_2001}.
Garcia et al.\ formalized typestate-oriented programming, showing how a typestate checker can statically ensure that an object method 
is only called when the object is in a state for which the operation is well defined\ \cite{garcia_foundations_2014}.
However, prior research has focused primarily on formalization and type theory rather than performance characteristics. 
Existing empirical work on typestate languages has examined usability\ \cite{coblenz_obsidian_2020} rather than runtime overhead.
No prior study has compared the assembly output of typestate implementations against equivalent C code at the instruction level.
This paper tries addresses that gap through assembly-level analysis of concrete implementations.

\section{Methodology}

The complete source code for all implementations, build scripts, and generated assembly are available at \url{https://github.com/failpark/zero_cost/}.
To isolate state management overhead from I/O latency, three variants of a minimal file handle abstraction were implemented (Figure~\ref{fig:state-machine}).
The handle stores only an integer \texttt{data} field, and operations simulate state transitions without actual file system calls.

\begin{figure}[H]
	\centering
	\includesvg[width=1.00\columnwidth,inkscapelatex=false]{svg/state_machine_manual_bottom}
	\caption{File handle state machine with four states and their transitions. Author's figure. Generated using PlantUML.}
	\label{fig:state-machine}
\end{figure}

Each implementation was compiled at -O2 optimization level: Apple Clang 17.0.0 for C, and rustc 1.91.1 with Rust edition 2024 for Rust.
Assembly was extracted using \texttt{objdump -d} on an Apple M3 chip (\texttt{aarch64-apple-darwin}).

Rust was compiled as a \texttt{cdylib} (C-compatible dynamic library) to prevent whole-program optimization from constant-folding the entire state machine.
Functions were marked with \texttt{\#[no\_mangle]} to preserve function boundaries for comparison.
The C implementations were compiled as shared libraries with equivalent settings (\texttt{-shared -fPIC}).

This study is limited to ARM64 architecture; results on other platforms such as x86-64 may differ.

Instructions and conditional branches were counted manually for each function, with assembly listings verified against compiler output.
Four state transition functions were analyzed: \texttt{open}, \texttt{read}, \texttt{get\_data}, and \texttt{close}.
These four functions represent all state transitions in the file handle state machine, providing complete coverage of the pattern's behavior.

\subsection{Defensive C Implementation}

The defensive implementation tracks state explicitly with an enum and validates preconditions before each operation:

\begin{listing}[H]
\begin{minted}{c}
int file_handle_get_data(file_handle_t* h) {
	if (h->state != STATE_READABLE) return -1;
	return h->data;
}
\end{minted}
\end{listing}

Each operation contains a conditional branch, producing comparison and jump instructions.

\subsection{Minimal C Implementation}

The minimal implementation omits all state tracking:

\begin{listing}[H]
\begin{minted}{c}
int file_handle_get_data(file_handle_t* h) {
	return h->data;
}
\end{minted}
\end{listing}

This version represents the performance ceiling but permits invalid operations.

\subsection{Rust Typestate Implementation}

The Rust implementation encodes each state as a zero-sized type:

\begin{listing}[H]
\begin{minted}{rust}
struct Closed; struct Open; struct Readable;

struct FileHandle<State> {
	data: i32,
	_state: PhantomData<State>,
}

impl FileHandle<Open> {
	fn read(self) -> FileHandle<Readable> {
		FileHandle { data: 42, _state: PhantomData }
	}
}

impl FileHandle<Readable> {
	fn get_data(&self) -> i32 { self.data }
}
\end{minted}
\end{listing}

The \texttt{PhantomData<State>} field is zero-sized and exists only for type checking.
The \texttt{get\_data} method is only defined for \texttt{FileHandle<Readable>}; calling it on other states produces a compile error.

\section{Results}

The defensive C implementation produced the following assembly for
\texttt{get\_data} (comments added for clarity; original \texttt{objdump} output contains only instructions):

\begin{minted}[fontsize=\scriptsize]{gas}
ldr  w8, [x0]        ; Load state field
cmp  w8, #0x2        ; Compare to READABLE
b.ne error           ; Branch if invalid
ldr  w0, [x0, #4]    ; Load data
ret
error:               ; Label (not an instruction)
mov  w0, #-1         ; Return error
ret
\end{minted}

This yields 7 instructions: 2 memory loads, 1 comparison, 1 conditional branch, 1 move, and 2 returns.
The label \texttt{error:} marks a branch target and is not counted as an instruction.
The 7-instruction count includes the error handling path; the happy path (valid state) requires 5 instructions,
but both paths must be present in the compiled binary.

The minimal C and Rust implementations both produced identical assembly:
\begin{minted}[fontsize=\scriptsize]{gas}
ldr  w0, [x0]        ; Load data directly
ret
\end{minted}
This yields 2 instructions: 1 memory operation and 1 return, with zero conditional branches.
\begin{figure}[H]
	\centering
	\includesvg[width=1.00\columnwidth,inkscapelatex=false]{figures/instruction_count.svg}
	\caption{Total instruction count comparison. Author's figure. Generated using matplotlib.}
	\label{fig:instruction-count}
\end{figure}

Figure~\ref{fig:instruction-count} demonstrates that Rust achieves the same instruction count
as minimal C---both implementations compile to exactly 2 instructions.
The defensive C implementation requires 3.5$\times$ the instructions due to explicit state checking logic.

\begin{figure}[H]
	\centering
	\includesvg[width=\columnwidth,inkscapelatex=false]{figures/instruction_breakdown.svg}
	\caption{Instruction category breakdown.  Author's figure. Generated using matplotlib.}
	\label{fig:instruction-breakdown}
\end{figure}

Figure~\ref{fig:instruction-breakdown} reveals the key insight:
Rust's typestate implementation contains zero conditional branch instructions, identical to minimal C.
The defensive C version includes a compare instruction (\texttt{cmp}) and one conditional branch (\texttt{b.ne}) that verify state validity at runtime.
These instructions represent the performance cost of runtime safety checks that Rust eliminates through compile-time verification.

\subsection{Multi-Function Analysis}

To verify that results generalize beyond a single function, all four state transition operations were analyzed using the same methodology.
Table~\ref{tab:multi-function} presents the complete results.

\begin{table}[H]
\centering
\caption{Instruction counts across all state transition functions at -O2 optimization.}
\label{tab:multi-function}
\begin{tabular}{lccc}
\hline
\textbf{Function} & \textbf{Defensive C} & \textbf{Minimal C / Rust} & \textbf{Overhead} \\
\hline
\texttt{get\_data} & 7 & 2 & 3.5$\times$ \\
\texttt{open} & 9 & 2 & 4.5$\times$ \\
\texttt{read} & 11 & 2 & 5.5$\times$ \\
\texttt{close} & 8 & 2 & 4.0$\times$ \\
\hline
\end{tabular}
\end{table}

Across all functions, Rust and minimal C produce byte-identical assembly, while defensive C requires 3.5--5.5$\times$ the instructions.
Complete assembly listings for all functions are available in the project repository for independent verification.

\section{Discussion}

The empirical results validate the zero-cost abstraction principle:
Rust's type-level state encoding produces assembly identical to minimal C while providing compile-time safety guarantees equivalent to defensive C's runtime checks.

\subsection{Implications for Security}

Google's Android team reported that as memory-unsafe code decreased, memory safety vulnerabilities dropped from 76\ \% in 2019 to 35\ \% in 2022\ \cite{google_android}.

The typestate pattern extends this principle beyond memory safety to protocol correctness.
Strom and Yemini's original formulation ensured that
``the sequence of operations on each variable obeys a finite state grammar associated with that variable's type''\ \cite{strom_typestate_1986}.
More recent work has shown how typestate can enforce that operations must be performed in a certain order
and that certain operations must be performed before accessing a given data object\ \cite{deline_enforcing_2001}.
APIs that enforce valid state sequences through types prevent logic errors through compile-time guarantees, not runtime checks that might be forgotten.

\subsection{Generalizability}

The consistency across all four analyzed functions strengthens confidence that
the zero-cost property is not an artifact of a single cherry-picked example.
The identical assembly output for Rust and minimal C across different state transitions suggests
that the typestate pattern reliably compiles away at optimization levels typical of production builds.

However, several factors limit generalizability.
First, LLVM's optimization behavior may differ across versions or with different optimization flags.
Second, the synthetic benchmark isolates state management from real-world concerns such as I/O, error propagation, and concurrent access.
Third, only a single state machine pattern was analyzed;
more complex state machines with additional fields or nested states may exhibit different behavior.

\section{Conclusion}

This paper compares three file handle implementations: defensive C with runtime validation, minimal C without checks, and Rust with compile-time typestate enforcement.
The empirical results validate the zero-cost abstraction principle:
Rust's typestate implementation produces assembly identical to minimal C (2 instructions, 0 branches)
while providing compile-time guarantees equivalent to defensive C's runtime checks (7 instructions, 2 branches).
Across four functions, defensive C consistently requires 3.5--5.5$\times$ more instructions.

These findings suggest that the traditional safety-performance tradeoff is not fundamental.
With sufficiently expressive type systems, safety can become a compile-time property with zero runtime cost.

\renewcommand*{\UrlFont}{\rmfamily}
\printbibliography

\end{document}
