@online{cwe_2025,
	title = {{CWE} - 2025 {CWE} Top 25 Most Dangerous Software Weaknesses},
	url = {https://web.archive.org/web/20251231122313/https://cwe.mitre.org/top25/archive/2025/2025_cwe_top25.html},
	shorttitle = {Common Weakness Enumeration},
	urldate = {2025-12-31},
	year = {2025},
	langid = {english},
}

@online{microsoft_safety,
	title = {We need a safer systems programming language},
	author = {{Microsoft Security Response Center}},
	url = {https://web.archive.org/web/20251205123558/https://www.microsoft.com/en-us/msrc/blog/2019/07/we-need-a-safer-systems-programming-language},
	year = {2019},
	month = {7},
	urldate = {2025-12-05},
	langid = {english},
}

@online{cisa_memory,
	title = {The Urgent Need for Memory Safety in Software Products},
	author = {{Cybersecurity and Infrastructure Security Agency}},
	url = {https://web.archive.org/web/20251223080013/https://www.cisa.gov/news-events/news/urgent-need-memory-safety-software-products},
	abstract = {Cybersecurity Technical Advisor Bob Lord stresses the importance of memory safety in making software safer by design.},
	year = {2023},
	month = {9},
	urldate = {2025-12-23},
	langid = {english},
}

@online{rust_embedded,
	title = {Zero Cost Abstractions - The Embedded Rust Book},
	author = {{Rust Embedded Working Group}},
	url = {https://web.archive.org/web/20251130072449/https://doc.rust-lang.org/beta/embedded-book/static-guarantees/zero-cost-abstractions.html},
	year = {2024},
	urldate = {2025-12-30},
	langid = {english},
}

@online{google_android,
	title = {Memory Safe Languages in Android 13},
	author = {Vander Stoep, Jeff and Hines, Stephen},
	url = {https://web.archive.org/web/20251224110719/https://security.googleblog.com/2022/12/memory-safe-languages-in-android-13.html},
	abstract = {Posted by Jeff Vander Stoep. For more than a decade, memory safety vulnerabilities have consistently represented more than 65\% of vulnerabilities.},
	journal = {Google Online Security Blog},
	year = {2022},
	month = {12},
	urldate = {2025-12-24},
	langid = {english},
}

@online{google_secure,
	title = {Secure by Design: Google's Perspective on Memory Safety},
	shorttitle = {Secure by Design},
	author = {Rebert, Alex and Kern, Christoph},
	url = {https://web.archive.org/web/20251229222029/https://security.googleblog.com/2024/03/secure-by-design-googles-perspective-on.html},
	abstract = {Alex Rebert, Software Engineer, Christoph Kern, Principal Engineer, Security Foundations Google's Project Zero reports that memory safety vulnerabilities.},
	journal = {Google Online Security Blog},
	year = {2024},
	month = {3},
	urldate = {2025-12-29},
	langid = {english},
}

@techreport{google_paper,
	title = {Secure by Design: Google's Perspective on Memory Safety},
	author = {Rebert, Alex and Kern, Christoph},
	url = {https://web.archive.org/web/20250831141723/https://storage.googleapis.com/gweb-research2023-media/pubtools/7665.pdf},
	year = {2024},
	month = {3},
	urldate = {2025-12-31},
	institution = {Google},
	langid = {english},
}

@techreport{oncd_report,
	title = {Back to the Building Blocks: A Path Toward Secure and Measurable Software},
	author = {{Office of the National Cyber Director}},
	url = {https://web.archive.org/web/20250120134421/https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf},
	year = {2024},
	month = {2},
	institution = {The White House},
	langid = {english},
}

@article{strom_typestate_1986,
	title = {Typestate: {A} programming language concept for enhancing software reliability},
	volume = {SE-12},
	issn = {1939-3520},
	shorttitle = {Typestate},
	url = {https://ieeexplore.ieee.org/document/6312929/},
	doi = {10.1109/TSE.1986.6312929},
	abstract = {The authors introduce a new programming language concept, called typestate, which is a refinement of the concept of type. Whereas the type of a data object determines the set of operations over permitted on the object, typestate determines the subset of these operations which is permitted in a particular context. Typestate tracking is a program analysis technique which enhances program reliability by detecting at compile-time syntactically legal but semantically undefined execution sequences. These include reading a variable before it has been initialized and dereferencing a pointer after the dynamic object has been deallocated. The authors define typestate, give examples of its application, and show how typestate checking may be embedded into a compiler. They discuss the consequences of typestate checking for software reliability and software structure, and summarize their experience in using a high-level language incorporating typestate checking.},
	number = {1},
	urldate = {2026-01-10},
	journal = {IEEE Transactions on Software Engineering},
	author = {Strom, Robert E. and Yemini, Shaula},
	month = jan,
	year = {1986},
	keywords = {Computer languages, Context, Law, Program analysis, Program processors, program verification, security, software reliability, Software reliability, type checking, typestate},
	pages = {157--171},
	file = {Full Text PDF:/Users/phedias/Zotero/storage/IJ92X2TS/Strom and Yemini - 1986 - Typestate A programming language concept for enhancing software reliability.pdf:application/pdf},
}

@inproceedings{strom_mechanisms_1983,
	address = {New York, NY, USA},
	series = {{POPL} '83},
	title = {Mechanisms for compile-time enforcement of security},
	isbn = {978-0-89791-090-3},
	url = {https://dl.acm.org/doi/10.1145/567067.567093},
	doi = {10.1145/567067.567093},
	abstract = {This paper discusses features of a secure systems programming language designed and implemented at IBM's Watson Research Lab. Two features of the language design were instrumental in permitting security to be enforced with minimum run-time cost: (1) Language constructs (e.g. pointer variables) which could result in aliasing were removed from the programmer's direct control and replaced by higher level primitive types; and (2) traditional strong type checking was enhanced with typestate checking, a new mechanism in which the compiler guarantees that for all execution paths, the sequence of operations on each variable obeys a finite state grammar associated with that variable's type. Examples are given to illustrate the application of these mechanisms.},
	urldate = {2026-01-10},
	booktitle = {Proceedings of the 10th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Strom, Robert E.},
	month = jan,
	year = {1983},
	pages = {276--284},
	file = {Full Text PDF:/Users/phedias/Zotero/storage/MX8UR8K7/Strom - 1983 - Mechanisms for compile-time enforcement of security.pdf:application/pdf},
}

@inproceedings{honda_types_1993,
	address = {Berlin, Heidelberg},
	title = {Types for dyadic interaction},
	isbn = {978-3-540-47968-0},
	doi = {10.1007/3-540-57208-2_35},
	abstract = {We formulate a typed formalism for concurrency where types denote freely composable structure of dyadic interaction in the symmetric scheme. The resulting calculus is a typed reconstruction of name passing process calculi. Systems with both the explicit and implicit typing disciplines, where types form a simple hierarchy of types, are presented, which are proved to be in accordance with each other. A typed variant of bisimilarity is formulated and it is shown that typed β-equality has a clean embedding in the bisimilarity. Name reference structure induced by the simple hierarchy of types is studied, which fully characterises the typable terms in the set of untyped terms. It turns out that the name reference structure results in the deadlock-free property for a subset of terms with a certain regular structure, showing behavioural significance of the simple type discipline.},
	language = {en},
	booktitle = {{CONCUR}'93},
	publisher = {Springer},
	author = {Honda, Kohei},
	editor = {Best, Eike},
	year = {1993},
	keywords = {Atomic Type, Constant Symbol, Dyadic Interaction, Functional Type, Reference Structure},
	pages = {509--523},
}

@online{rust_reference_phantomdata,
	title = {{PhantomData} in std::marker - {Rust}},
	url = {https://web.archive.org/web/20260106142924/https://doc.rust-lang.org/std/marker/struct.PhantomData.html},
	urldate = {2026-01-06},
	author = {{Rust Project}},
	langid = {english},
}

@online{rustonomicon,
	title = {{PhantomData} - {The} {Rustonomicon}},
	author = {{Rust Project}},
	url = {https://web.archive.org/web/20260101042551/https://doc.rust-lang.org/nomicon/phantom-data.html},
	urldate = {2026-01-01},
	author = {{Rust Project}},
	langid = {english},
}

@inproceedings{astrauskas_leveraging_2019,
	title = {Leveraging {Rust} Types for Modular Specification and Verification},
	doi = {10.1145/3360573},
	booktitle = {Proceedings of the {ACM} on Programming Languages ({OOPSLA})},
	author = {Astrauskas, Vytautas and Müller, Peter and Poli, Federico and Summers, Alexander J.},
	year = {2019},
	volume = {3},
	number = {OOPSLA},
	pages = {1--30},
	articleno = {147},
}

@inproceedings{deline_enforcing_2001,
	title = {Enforcing High-Level Protocols in Low-Level Software},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 2001 Conference on Programming Language Design and Implementation ({PLDI})},
	author = {DeLine, Robert and Fähndrich, Manuel},
	year = {2001},
	month = {6},
	pages = {59--69},
	publisher = {ACM},
	address = {Snowbird, Utah, USA},
	doi = {10.1145/378795.378811},
}

@inproceedings{deline_typestates_2004,
	title = {Typestates for Objects},
	booktitle = {{ECOOP} 2004 -- Object-Oriented Programming, 18th European Conference},
	series = {Lecture Notes in Computer Science},
	volume = {3086},
	author = {DeLine, Robert and Fähndrich, Manuel},
	editor = {Odersky, Martin},
	year = {2004},
	pages = {465--490},
	publisher = {Springer},
	address = {Oslo, Norway},
	doi = {10.1007/978-3-540-24851-4_21},
}

@article{garcia_foundations_2014,
	title = {Foundations of Typestate-Oriented Programming},
	volume = {36},
	doi = {10.1145/2629609},
	number = {4},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Garcia, Ronald and Tanter, Éric and Wolff, Roger and Aldrich, Jonathan},
	year = {2014},
	month = {10},
	pages = {1--44},
	articleno = {12},
}

@article{coblenz_obsidian_2020,
	title = {Can Advanced Type Systems Be Usable? {An} Empirical Study of Ownership, Assets, and Typestate in {Obsidian}},
	volume = {4},
	doi = {10.1145/3428200},
	number = {OOPSLA},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Coblenz, Michael and Aldrich, Jonathan and Myers, Brad A. and Sunshine, Joshua},
	year = {2020},
	month = {11},
	articleno = {132},
}

